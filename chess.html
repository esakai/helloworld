<!-- ここからHTML全体の例 -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>コンピューター対戦チェス（改良版）</title>
  <style>
    body { background: #eee; font-family: sans-serif; text-align: center; }
    #message { margin: 10px; font-size: 20px; }
    canvas { border: 2px solid #333; }
  </style>
</head>
<body>
  <div id="message">Turn: Human (White)</div>
  <canvas id="chessCanvas" width="480" height="480"></canvas>

  <script>
    // ----- キャンバス・グローバル変数など -----
    var canvas = document.getElementById("chessCanvas");
    var ctx = canvas.getContext("2d");
    var cellSize = 60;
    var gameOver = false;

    // キャスリング用移動済みフラグ
    var whiteKingMoved = false, blackKingMoved = false;
    var whiteKingsideRookMoved = false, whiteQueensideRookMoved = false;
    var blackKingsideRookMoved = false, blackQueensideRookMoved = false;

    // 初期盤面（上段：黒、下段：白）
    var board = [
      ["bR","bN","bB","bQ","bK","bB","bN","bR"],
      ["bP","bP","bP","bP","bP","bP","bP","bP"],
      [null, null, null, null, null, null, null, null],
      [null, null, null, null, null, null, null, null],
      [null, null, null, null, null, null, null, null],
      [null, null, null, null, null, null, null, null],
      ["wP","wP","wP","wP","wP","wP","wP","wP"],
      ["wR","wN","wB","wQ","wK","wB","wN","wR"]
    ];

    var pieceSymbols = {
      "wK": "♔", "wQ": "♕", "wR": "♖", "wB": "♗", "wN": "♘", "wP": "♙",
      "bK": "♚", "bQ": "♛", "bR": "♜", "bB": "♝", "bN": "♞", "bP": "♟"
    };

    var currentTurn = "w"; // "w" = Human (White), "b" = Computer (Black)
    var selected = null;

    // ----- 描画、UI更新などの関数（以前のコードと同様） -----
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          var x = col * cellSize;
          var y = row * cellSize;
          ctx.fillStyle = ((row + col) % 2 === 0) ? "#f0d9b5" : "#b58863";
          ctx.fillRect(x, y, cellSize, cellSize);
          if (selected && selected.row === row && selected.col === col) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 3;
            ctx.strokeRect(x+1, y+1, cellSize-2, cellSize-2);
          }
          if (board[row][col]) {
            var piece = board[row][col];
            ctx.font = "48px serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "black";
            ctx.fillText(pieceSymbols[piece], x + cellSize/2, y + cellSize/2 + 4);
          }
        }
      }
    }

    function updateMessage() {
      if (gameOver) return;
      document.getElementById("message").innerText =
         (currentTurn === "w") ? "Turn: Human (White)" : "Turn: Computer (Black)";
    }

    canvas.addEventListener("click", function(event) {
      if (gameOver || currentTurn !== "w") return;
      var rect = canvas.getBoundingClientRect();
      var x = event.clientX - rect.left;
      var y = event.clientY - rect.top;
      var col = Math.floor(x / cellSize);
      var row = Math.floor(y / cellSize);
      onCellClick(row, col);
    });

    function onCellClick(row, col) {
      if (gameOver) return;
      if (!selected) {
        if (board[row][col] && board[row][col][0] === "w") {
          selected = { row: row, col: col };
          drawBoard();
        }
      } else {
        if (selected.row === row && selected.col === col) {
          selected = null;
          drawBoard();
          return;
        }
        if (isLegalMove(selected.row, selected.col, row, col)) {
          movePiece(selected.row, selected.col, row, col);
          selected = null;
          drawBoard();
          if (!gameOver && currentTurn === "b") {
            setTimeout(computerMove, 500);
          }
        } else {
          alert("不正な動きです");
          selected = null;
          drawBoard();
        }
      }
    }

    // ----- movePiece 関数（キャスリング、パーン昇格、移動済みフラグ更新など） -----
    function movePiece(fromRow, fromCol, toRow, toCol) {
      var piece = board[fromRow][fromCol];
      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = null;
      if (piece === "wK") whiteKingMoved = true;
      if (piece === "bK") blackKingMoved = true;
      if (piece === "wR") {
        if (fromRow === 7 && fromCol === 0) whiteQueensideRookMoved = true;
        if (fromRow === 7 && fromCol === 7) whiteKingsideRookMoved = true;
      }
      if (piece === "bR") {
        if (fromRow === 0 && fromCol === 0) blackQueensideRookMoved = true;
        if (fromRow === 0 && fromCol === 7) blackKingsideRookMoved = true;
      }
      // キャスリングの場合：キングが横に2マス動いていると判断
      if ((piece === "wK" || piece === "bK") && Math.abs(toCol - fromCol) === 2) {
        if (piece === "wK") {
          if (toCol === 6) { // キングサイド
            board[7][5] = board[7][7];
            board[7][7] = null;
            whiteKingsideRookMoved = true;
          } else if (toCol === 2) { // クイーンサイド
            board[7][3] = board[7][0];
            board[7][0] = null;
            whiteQueensideRookMoved = true;
          }
        }
        if (piece === "bK") {
          if (toCol === 6) {
            board[0][5] = board[0][7];
            board[0][7] = null;
            blackKingsideRookMoved = true;
          } else if (toCol === 2) {
            board[0][3] = board[0][0];
            board[0][0] = null;
            blackQueensideRookMoved = true;
          }
        }
      }
      // パーン昇格
      if (piece[1] === "P") {
        if ((piece[0] === "w" && toRow === 0) || (piece[0] === "b" && toRow === 7)) {
          board[toRow][toCol] = piece[0] + "Q";
        }
      }
      currentTurn = (currentTurn === "w") ? "b" : "w";
      updateMessage();
      checkGameOver();
    }

    // ----- ここから「評価関数」を使ったコンピューター側の処理改善 -----
    // 局面評価関数：黒側の駒の合計価値 - 白側の駒の合計価値
    function evaluateBoard(b) {
      var value = 0;
      var pieceValue = { "P": 1, "N": 3, "B": 3, "R": 5, "Q": 9, "K": 1000 };
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          var piece = b[row][col];
          if (piece) {
            var sign = (piece[0] === "b") ? 1 : -1;
            value += sign * (pieceValue[piece[1]] || 0);
          }
        }
      }
      return value;
    }

    // コンピューター側の手：すべての合法手をシミュレーションし、評価値が最大になる手を選ぶ
    function computerMove() {
      if (gameOver) return;
      var moves = [];
      // 黒のすべての合法手を収集
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          var piece = board[row][col];
          if (piece && piece[0] === "b") {
            for (var r = 0; r < 8; r++) {
              for (var c = 0; c < 8; c++) {
                if (isLegalMove(row, col, r, c)) {
                  // ※　チェック回避も含めるため、シミュレーション後にキングが守られているかも確認
                  var newBoard = simulateMoveOnBoard(board, row, col, r, c);
                  if (!isInCheckOnBoard(newBoard, "b")) {
                    moves.push({ fromRow: row, fromCol: col, toRow: r, toCol: c });
                  }
                }
              }
            }
          }
        }
      }
      if (moves.length === 0) {
        alert("コンピューターは動けません。ゲーム終了！");
        gameOver = true;
        return;
      }
      // 各候補手について局面評価を計算し、最高評価の手を選択
      var bestScore = -Infinity;
      var bestMoves = [];
      for (var i = 0; i < moves.length; i++) {
        var move = moves[i];
        var newBoard = simulateMoveOnBoard(board, move.fromRow, move.fromCol, move.toRow, move.toCol);
        var score = evaluateBoard(newBoard);
        if (score > bestScore) {
          bestScore = score;
          bestMoves = [move];
        } else if (score === bestScore) {
          bestMoves.push(move);
        }
      }
      var chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
      movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
      drawBoard();
      if (!gameOver && currentTurn === "b") {
        setTimeout(computerMove, 500);
      }
    }

    // ----- 以下はこれまでと同様の「移動ルール」や「チェック判定」用関数群 -----
    function isLegalMove(fromRow, fromCol, toRow, toCol) {
      var piece = board[fromRow][fromCol];
      if (!piece) return false;
      var color = piece[0], type = piece[1];
      var dest = board[toRow][toCol];
      if (dest && dest[0] === color) return false;
      var dRow = toRow - fromRow, dCol = toCol - fromCol;
      switch (type) {
        case "P":
          if (color === "w") {
            if (dCol === 0 && dRow === -1 && board[toRow][toCol] === null) return true;
            if (dCol === 0 && dRow === -2 && fromRow === 6 &&
                board[fromRow - 1][fromCol] === null && board[toRow][toCol] === null)
              return true;
            if (Math.abs(dCol) === 1 && dRow === -1 &&
                board[toRow][toCol] && board[toRow][toCol][0] === "b")
              return true;
          } else {
            if (dCol === 0 && dRow === 1 && board[toRow][toCol] === null) return true;
            if (dCol === 0 && dRow === 2 && fromRow === 1 &&
                board[fromRow + 1][fromCol] === null && board[toRow][toCol] === null)
              return true;
            if (Math.abs(dCol) === 1 && dRow === 1 &&
                board[toRow][toCol] && board[toRow][toCol][0] === "w")
              return true;
          }
          return false;
        case "R":
          if (dRow === 0 && dCol !== 0) return isPathClear(fromRow, fromCol, toRow, toCol);
          if (dCol === 0 && dRow !== 0) return isPathClear(fromRow, fromCol, toRow, toCol);
          return false;
        case "N":
          if ((Math.abs(dRow) === 2 && Math.abs(dCol) === 1) ||
              (Math.abs(dRow) === 1 && Math.abs(dCol) === 2))
            return true;
          return false;
        case "B":
          if (Math.abs(dRow) === Math.abs(dCol) && dRow !== 0)
            return isPathClear(fromRow, fromCol, toRow, toCol);
          return false;
        case "Q":
          if (dRow === 0 && dCol !== 0) return isPathClear(fromRow, fromCol, toRow, toCol);
          if (dCol === 0 && dRow !== 0) return isPathClear(fromRow, fromCol, toRow, toCol);
          if (Math.abs(dRow) === Math.abs(dCol) && dRow !== 0)
            return isPathClear(fromRow, fromCol, toRow, toCol);
          return false;
        case "K":
          if (Math.abs(dRow) <= 1 && Math.abs(dCol) <= 1) return true;
          if (dRow === 0 && Math.abs(dCol) === 2) {
            if (color === "w" && fromRow === 7 && fromCol === 4 && !whiteKingMoved) {
              if (dCol === 2) {
                if (whiteKingsideRookMoved || board[7][7] !== "wR") return false;
                if (board[7][5] !== null || board[7][6] !== null) return false;
                if (isSquareAttacked(7, 4, "w")) return false;
                var simBoard = simulateMoveOnBoard(board, 7, 4, 7, 5);
                if (isSquareAttackedOnBoard(simBoard, 7, 5, "w")) return false;
                var simBoard2 = simulateMoveOnBoard(board, 7, 4, 7, 6);
                if (isSquareAttackedOnBoard(simBoard2, 7, 6, "w")) return false;
                return true;
              } else if (dCol === -2) {
                if (whiteQueensideRookMoved || board[7][0] !== "wR") return false;
                if (board[7][1] !== null || board[7][2] !== null || board[7][3] !== null) return false;
                if (isSquareAttacked(7, 4, "w")) return false;
                var simBoard = simulateMoveOnBoard(board, 7, 4, 7, 3);
                if (isSquareAttackedOnBoard(simBoard, 7, 3, "w")) return false;
                var simBoard2 = simulateMoveOnBoard(board, 7, 4, 7, 2);
                if (isSquareAttackedOnBoard(simBoard2, 7, 2, "w")) return false;
                return true;
              }
            } else if (color === "b" && fromRow === 0 && fromCol === 4 && !blackKingMoved) {
              if (dCol === 2) {
                if (blackKingsideRookMoved || board[0][7] !== "bR") return false;
                if (board[0][5] !== null || board[0][6] !== null) return false;
                if (isSquareAttacked(0, 4, "b")) return false;
                var simBoard = simulateMoveOnBoard(board, 0, 4, 0, 5);
                if (isSquareAttackedOnBoard(simBoard, 0, 5, "b")) return false;
                var simBoard2 = simulateMoveOnBoard(board, 0, 4, 0, 6);
                if (isSquareAttackedOnBoard(simBoard2, 0, 6, "b")) return false;
                return true;
              } else if (dCol === -2) {
                if (blackQueensideRookMoved || board[0][0] !== "bR") return false;
                if (board[0][1] !== null || board[0][2] !== null || board[0][3] !== null) return false;
                if (isSquareAttacked(0, 4, "b")) return false;
                var simBoard = simulateMoveOnBoard(board, 0, 4, 0, 3);
                if (isSquareAttackedOnBoard(simBoard, 0, 3, "b")) return false;
                var simBoard2 = simulateMoveOnBoard(board, 0, 4, 0, 2);
                if (isSquareAttackedOnBoard(simBoard2, 0, 2, "b")) return false;
                return true;
              }
            }
            return false;
          }
          return false;
        default:
          return false;
      }
    }

    function isPathClear(fromRow, fromCol, toRow, toCol) {
      var dRow = toRow - fromRow, dCol = toCol - fromCol;
      var stepRow = dRow === 0 ? 0 : (dRow > 0 ? 1 : -1);
      var stepCol = dCol === 0 ? 0 : (dCol > 0 ? 1 : -1);
      var currentRow = fromRow + stepRow, currentCol = fromCol + stepCol;
      while (currentRow !== toRow || currentCol !== toCol) {
        if (board[currentRow][currentCol] !== null) return false;
        currentRow += stepRow;
        currentCol += stepCol;
      }
      return true;
    }

    // ----- シミュレーション・チェック用関数群 -----
    function simulateMoveOnBoard(b, fromRow, fromCol, toRow, toCol) {
      var newBoard = [];
      for (var i = 0; i < 8; i++) {
        newBoard[i] = b[i].slice();
      }
      var movedPiece = newBoard[fromRow][fromCol];
      newBoard[toRow][toCol] = movedPiece;
      newBoard[fromRow][fromCol] = null;
      if (movedPiece && movedPiece[1] === "P") {
        if ((movedPiece[0] === "w" && toRow === 0) ||
            (movedPiece[0] === "b" && toRow === 7)) {
          newBoard[toRow][toCol] = movedPiece[0] + "Q";
        }
      }
      return newBoard;
    }

    function isLegalMoveOnBoard(b, fromRow, fromCol, toRow, toCol) {
      var piece = b[fromRow][fromCol];
      if (!piece) return false;
      var color = piece[0], type = piece[1];
      var dest = b[toRow][toCol];
      if (dest && dest[0] === color) return false;
      var dRow = toRow - fromRow, dCol = toCol - fromCol;
      switch (type) {
        case "P":
          if (color === "w") {
            if (dCol === 0 && dRow === -1 && b[toRow][toCol] === null) return true;
            if (dCol === 0 && dRow === -2 && fromRow === 6 &&
                b[fromRow - 1][fromCol] === null && b[toRow][toCol] === null)
              return true;
            if (Math.abs(dCol) === 1 && dRow === -1 &&
                b[toRow][toCol] && b[toRow][toCol][0] === "b") return true;
          } else {
            if (dCol === 0 && dRow === 1 && b[toRow][toCol] === null) return true;
            if (dCol === 0 && dRow === 2 && fromRow === 1 &&
                b[fromRow + 1][fromCol] === null && b[toRow][toCol] === null)
              return true;
            if (Math.abs(dCol) === 1 && dRow === 1 &&
                b[toRow][toCol] && b[toRow][toCol][0] === "w") return true;
          }
          return false;
        case "R":
          if (dRow === 0 && dCol !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          if (dCol === 0 && dRow !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          return false;
        case "N":
          if ((Math.abs(dRow) === 2 && Math.abs(dCol) === 1) ||
              (Math.abs(dRow) === 1 && Math.abs(dCol) === 2)) return true;
          return false;
        case "B":
          if (Math.abs(dRow) === Math.abs(dCol) && dRow !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          return false;
        case "Q":
          if (dRow === 0 && dCol !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          if (dCol === 0 && dRow !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          if (Math.abs(dRow) === Math.abs(dCol) && dRow !== 0) return isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol);
          return false;
        case "K":
          if (Math.abs(dRow) <= 1 && Math.abs(dCol) <= 1) return true;
          return false;
        default:
          return false;
      }
    }

    function isPathClearOnBoard(b, fromRow, fromCol, toRow, toCol) {
      var dRow = toRow - fromRow, dCol = toCol - fromCol;
      var stepRow = dRow === 0 ? 0 : (dRow > 0 ? 1 : -1);
      var stepCol = dCol === 0 ? 0 : (dCol > 0 ? 1 : -1);
      var currentRow = fromRow + stepRow, currentCol = fromCol + stepCol;
      while (currentRow !== toRow || currentCol !== toCol) {
        if (b[currentRow][currentCol] !== null) return false;
        currentRow += stepRow;
        currentCol += stepCol;
      }
      return true;
    }

    function isInCheckOnBoard(b, color) {
      var kingRow = -1, kingCol = -1;
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          if (b[i][j] === color + "K") {
            kingRow = i; kingCol = j; break;
          }
        }
        if (kingRow !== -1) break;
      }
      if (kingRow === -1) return true;
      var opponent = (color === "w") ? "b" : "w";
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var piece = b[i][j];
          if (piece && piece[0] === opponent) {
            if (isLegalMoveOnBoard(b, i, j, kingRow, kingCol)) return true;
          }
        }
      }
      return false;
    }

    function canMove(color) {
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var piece = board[i][j];
          if (piece && piece[0] === color) {
            for (var r = 0; r < 8; r++) {
              for (var c = 0; c < 8; c++) {
                if (isLegalMove(i, j, r, c)) {
                  var newBoard = simulateMoveOnBoard(board, i, j, r, c);
                  if (!isInCheckOnBoard(newBoard, color)) return true;
                }
              }
            }
          }
        }
      }
      return false;
    }

    function isCheckmate(color) {
      if (!isInCheckOnBoard(board, color)) return false;
      if (canMove(color)) return false;
      return true;
    }

    function checkGameOver() {
      if (isCheckmate(currentTurn)) {
        gameOver = true;
        var winner = (currentTurn === "w") ? "Black" : "White";
        document.getElementById("message").innerText = "Checkmate! " + winner + " wins!";
      }
    }

    function isSquareAttacked(row, col, color) {
      var opponent = (color === "w") ? "b" : "w";
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var piece = board[i][j];
          if (piece && piece[0] === opponent) {
            if (isLegalMoveOnBoard(board, i, j, row, col)) return true;
          }
        }
      }
      return false;
    }

    function isSquareAttackedOnBoard(b, row, col, color) {
      var opponent = (color === "w") ? "b" : "w";
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var piece = b[i][j];
          if (piece && piece[0] === opponent) {
            if (isLegalMoveOnBoard(b, i, j, row, col)) return true;
          }
        }
      }
      return false;
    }

    // ----- 改善したコンピューター側の手選択（1手先評価） -----
    function computerMove() {
      if (gameOver) return;
      var moves = [];
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          var piece = board[row][col];
          if (piece && piece[0] === "b") {
            for (var r = 0; r < 8; r++) {
              for (var c = 0; c < 8; c++) {
                if (isLegalMove(row, col, r, c)) {
                  var newBoard = simulateMoveOnBoard(board, row, col, r, c);
                  if (!isInCheckOnBoard(newBoard, "b")) {
                    moves.push({ fromRow: row, fromCol: col, toRow: r, toCol: c });
                  }
                }
              }
            }
          }
        }
      }
      if (moves.length === 0) {
        alert("コンピューターは動けません。ゲーム終了！");
        gameOver = true;
        return;
      }
      var bestScore = -Infinity;
      var bestMoves = [];
      for (var i = 0; i < moves.length; i++) {
        var move = moves[i];
        var newBoard = simulateMoveOnBoard(board, move.fromRow, move.fromCol, move.toRow, move.toCol);
        var score = evaluateBoard(newBoard);
        if (score > bestScore) {
          bestScore = score;
          bestMoves = [move];
        } else if (score === bestScore) {
          bestMoves.push(move);
        }
      }
      var chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
      movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
      drawBoard();
      if (!gameOver && currentTurn === "b") {
        setTimeout(computerMove, 500);
      }
    }

    // ----- 初期描画 -----
    drawBoard();
    updateMessage();
  </script>
</body>
</html>
